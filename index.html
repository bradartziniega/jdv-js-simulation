<html>
  <head>
    <style>
      body {
        margin: 0px;
        padding: 0px;
        background-color: white;
      }

      #container{
      	background-color: white;
      }
    </style>

	<script src='js/DAT.GUI.min.js'></script>
	<script src="js/Three.js"></script>
	<script src="js/Detector.js"></script>
	<script src="js/Stats.js"></script>
	<script src="js/OrbitControls.js"></script>
	<script src="js/THREEx.KeyboardState.js"></script>
	<script src="js/THREEx.FullScreen.js"></script>
	<script src="js/THREEx.WindowResize.js"></script>
    <script src="js/Tween.js"></script>

    <script src="js/perlin.js"></script>
    

  </head>
  <body>
  	<div id="ThreeJS"></div>

    <script defer="defer">
      
      
      var startTime	= Date.now();
      var camera, controls, scene, renderer;
      var spheres;
      var multiplier_1;
      var multiplier_2;
	  var multiplier_3;

      // bulb radius in mm
      var radiusSphere = 65;
      // spacing between bulbs
      var spacingSphere = 230;
      // max travel length from start
      var maxtravelSphere = 2450;

      init();
      animate();

      THREE.Color.prototype.getHSV = function()
		{
		    var rr, gg, bb,
		        h, s,
		        r = this.r,
		        g = this.g,
		        b = this.b,
		        v = Math.max(r, g, b),
		        diff = v - Math.min(r, g, b),
		        diffc = function(c)
		        {
		            return (v - c) / 6 / diff + 1 / 2;
		        };

		    if (diff == 0) {
		        h = s = 0;
		    } else {
		        s = diff / v;
		        rr = diffc(r);
		        gg = diffc(g);
		        bb = diffc(b);

		        if (r === v) {
		            h = bb - gg;
		        } else if (g === v) {
		            h = (1 / 3) + rr - bb;
		        } else if (b === v) {
		            h = (2 / 3) + gg - rr;
		        }
		        if (h < 0) {
		            h += 1;
		        } else if (h > 1) {
		            h -= 1;
		        }
		    }
		    return {
		        h: h,
		        s: s,
		        v: v
		    };
		};

		function addDatGui(){
			var gui = new dat.GUI();

			 parameters = 
        		{
        		multiplier_1: 0.01,
        		multiplier_2: 0.01,
        		multiplier_3: 0.01
        		};

			gui.add(camera.position, 'x', -5000,5000).step(5);
			gui.add(camera.position, 'y', -5000,5000).step(5);
			gui.add(camera.position, 'z', 0,10000).step(5);
			multiplier_1 = gui.add(parameters,'multiplier_1',0.0,1.0).step(0.001);
			multiplier_2 = gui.add(parameters,'multiplier_2',0.0,1.0).step(0.001);
			multiplier_3 = gui.add(parameters,'multiplier_3',0.0,1.0).step(0.001);

		}

      function init(){

		camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
		camera.position.x = 0;
		camera.position.y = -5000;
		camera.position.z = 1750;
		
		//scene
		scene = new THREE.Scene();
		
		//renderer
		if ( Detector.webgl )
                renderer = new THREE.WebGLRenderer( {antialias:true} );
        else
                renderer = new THREE.CanvasRenderer(); 

		renderer.setSize(window.innerWidth, window.innerHeight);
		container = document.getElementById('ThreeJS');
		container.appendChild(renderer.domElement);

		renderer.setClearColorHex( 0x000000, 1 );

		// shadow casting test
		renderer.shadowMapEnabled = true;
		renderer.shadowMapSoft = true;

		renderer.shadowCameraNear = 3;
		renderer.shadowCameraFar = camera.far;
		renderer.shadowCameraFov = 50;

		renderer.shadowMapBias = 0.0039;
		renderer.shadowMapDarkness = 0.5;
		renderer.shadowMapWidth = 1024;
		renderer.shadowMapHeight = 1024;
		//

		controls = new THREE.OrbitControls( camera, renderer.domElement );

		var radius = radiusSphere;
		spheres = new Array(10);
		brightness = new Array(10);
		lights = new Array(10);
		for(var i=0;i<10;i++){
			spheres[i] = new Array(i);
			brightness[i] = new Array(i);
			lights[i] = new Array(i);
		}

		var colorMat = new THREE.Color();
		colorMat.setHSL(64/360,86/100,1);		
		var sphereMaterial = new THREE.MeshBasicMaterial({color:colorMat});


	    for(var i=0;i<10;i++){
	     	for(var j=0;j<10;j++){

	     		spheres[i][j] = new THREE.Mesh(new THREE.SphereGeometry(radius, radius, radius), sphereMaterial);
	     		brightness[i][j] = 0;
			    spheres[i][j].overdraw = true;
			    spheres[i][j].position = new THREE.Vector3((i-4)*(spacingSphere + radius*2), (j-4)*(spacingSphere + radius*2), 1000);
			    scene.add(spheres[i][j]);   

	  		}
	 	}	

	 	var ambientLight = new THREE.AmbientLight(0xFFFF66);
      	scene.add(ambientLight);

      	addDatGui();

      	noise.seed(Math.random());

      }

		function animate(){

			render();
			requestAnimationFrame( animate );
			controls.update();

		}


		function visual_Sine() {
			var dtime = Date.now() - startTime;
			for(var i=0;i<10;i++){
		     	for(var j=0;j<10;j++){
				   	spheres[i][j].position.z = 100*Math.sin((j+1)*dtime/3000);
		  			brightness[i][j] = Math.abs(spheres[i][j].position.z) / 100;
		  			var colorMat = new THREE.Color();
		  			colorMat.setHSL(64/360,86/100,0.3*brightness[i][j]+0.2);
		  			spheres[i][j].material = new THREE.MeshBasicMaterial({color:colorMat});

		  		}
		 	}
		}


		function visual_Noise2d() {
			var dtime = Date.now() - startTime;
			var div = 0.01;
			for(var i=0;i<10;i++){
		     	for(var j=0;j<10;j++){


					spheres[i][j].position.z = noise.perlin3(1,spheres[i][j].position.x*parameters.multiplier_1,spheres[i][j].position.y*parameters.multiplier_1)*(maxtravelSphere)*Math.sin(dtime/10000 + spheres[i][j].position.x*spheres[i][j].position.y);

					brightness[i][j] = 0.1 + Math.abs(noise.perlin3(1,spheres[j][i].position.y*div,spheres[j][i].position.x*div)*Math.sin(dtime/1000 + spheres[i][j].position.x*spheres[i][j].position.y));

					var colorMat = new THREE.Color();
		  			colorMat.setHSL(64/360,86/100,0.5*brightness[i][j]+0.2);
		  			spheres[i][j].material = new THREE.MeshBasicMaterial({color:colorMat});
				}
			}
		}

		function render() {
		 	//visual_Sine();
		 	visual_Noise2d();
			renderer.render( scene, camera );
		}
		


    </script>


 

  </body>
</html>