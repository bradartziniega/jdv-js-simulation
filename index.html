<html>
  <head>
    <style>
      body {
        margin: 0px;
        padding: 0px;
        background-color: white;
      }

      #container{
      	background-color: white;
      }
    </style>

	<script type='text/javascript' src='scripts/DAT.GUI.min.js'></script>
  	<script src="scripts/three.min.js"></script>
    <script src="scripts/TrackballControls.js"></script>
    <script src="scripts/perlin.js"></script>

  </head>
  <body>
  	<div id="container"></div>

    <script defer="defer">
      
      
      var startTime	= Date.now();
      var camera, controls, scene, renderer;
      var spheres;

      // bulb radius in mm
      var radiusSphere = 65;
      // spacing between bulbs
      var spacingSphere = 230;
      // max travel length from start
      var maxtravelSphere = 2450;

      init();
      animate();

		function addDatGui(){
			var gui = new dat.GUI();
			gui.add(camera.position, 'x', -5000,5000).step(5);
			gui.add(camera.position, 'y', -5000,5000).step(5);
			gui.add(camera.position, 'z', 0,10000).step(5);
		}

      function init(){

		camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
		camera.position.x = 0;
		camera.position.y = -5000;
		camera.position.z = 1750;
		
		//scene
		scene = new THREE.Scene();
		
		//renderer
		renderer = new THREE.WebGLRenderer();
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.setClearColorHex( 0x000000, 1 );

		// shadow casting test
		renderer.shadowMapEnabled = true;
		renderer.shadowMapSoft = true;

		renderer.shadowCameraNear = 3;
		renderer.shadowCameraFar = camera.far;
		renderer.shadowCameraFov = 50;

		renderer.shadowMapBias = 0.0039;
		renderer.shadowMapDarkness = 0.5;
		renderer.shadowMapWidth = 1024;
		renderer.shadowMapHeight = 1024;
		//


		controls = new THREE.TrackballControls( camera );//, renderer.domElement );
		controls.rotateSpeed = 1.0;
		controls.zoomSpeed = 1.2;
		controls.panSpeed = 0.8;
		controls.noZoom = false;
		controls.noPan = false;
		controls.staticMoving = true;
		controls.dynamicDampingFactor = 0.3;
		controls.keys = [ 65, 83, 68 ];
		controls.addEventListener( 'change', render );

		var container = document.getElementById( 'container' );
		container.appendChild( renderer.domElement );

		var radius = radiusSphere;
		spheres = new Array(10);
		brightness = new Array(10);
		lights = new Array(10);
		for(var i=0;i<10;i++){
			spheres[i] = new Array(i);
			brightness[i] = new Array(i);
			lights[i] = new Array(i);
		}

		var sphereMaterial = new THREE.MeshLambertMaterial({color: 0xFFFFFF, transparent: true, opacity: 1});


	    for(var i=0;i<10;i++){
	     	for(var j=0;j<10;j++){

	     		spheres[i][j] = new THREE.Mesh(new THREE.SphereGeometry(radius, radius, radius), sphereMaterial);
	     		brightness[i][j] = 0;
			    spheres[i][j].overdraw = true;

			    spheres[i][j].position = new THREE.Vector3((i-4)*(spacingSphere + radius*2), (j-4)*(spacingSphere + radius*2), 1000);
			    scene.add(spheres[i][j]);   

	  		}
	 	}	

	 	var ambientLight = new THREE.AmbientLight(0xFFFF66);
      	scene.add(ambientLight);

      	addDatGui();

      	noise.seed(Math.random());

      }

		function animate(){

			render();
			requestAnimationFrame( animate );
			controls.update();

		}


		function visual_Sine() {
			var dtime = Date.now() - startTime;
			for(var i=0;i<10;i++){
		     	for(var j=0;j<10;j++){
				   	spheres[i][j].position.z = 100*Math.sin((j+1)*dtime/3000);
		  			brightness[i][j] = Math.abs(spheres[i][j].position.z) / 100;
		  			spheres[i][j].material = new THREE.MeshLambertMaterial({color: 0xffffff, transparent: true, opacity: brightness[i][j]});
		  		}
		 	}
		}

		function visual_Noise2d() {
			var dtime = Date.now() - startTime;
			var div = 0.01;
			for(var i=0;i<10;i++){
		     	for(var j=0;j<10;j++){
					spheres[i][j].position.z = noise.perlin3(1,spheres[i][j].position.x*div,spheres[i][j].position.y*div)*(maxtravelSphere)*Math.sin(dtime/10000 + spheres[i][j].position.x*spheres[i][j].position.y);

					brightness[i][j] = 0.1 + Math.abs(noise.perlin3(1,spheres[j][i].position.y*div,spheres[j][i].position.x*div)*Math.sin(dtime/10000 + spheres[i][j].position.x*spheres[i][j].position.y));
		  			spheres[i][j].material = new THREE.MeshLambertMaterial({color: 0xFFFFFF, transparent: true, opacity: brightness[i][j]});
				}
			}
		}

		function render() {
		 	//visual_Sine();
		 	visual_Noise2d();
			renderer.render( scene, camera );
		}
		


    </script>


 

  </body>
</html>